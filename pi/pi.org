#+TITLE: On the computation of \pi
#+LANGUAGE: en

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+PROPERTY: header-args  :session  :exports both

* Asking the math library

My computer tells me that \pi is /approximatively/

#+begin_src python :results value :session :exports both
from math import *
pi
#+end_src

#+RESULTS:
: 3.141592653589793


* Buffon's needle

Applying the method of [[http://www.cut-the-knot.org/fta/Buffon/buffon9.shtml][Buffon's needle]] we get the *approximation*

#+begin_src python :results value :session :exports both
import numpy as np

N = 10000
np.random.seed(seed=42)

x = np.random.uniform(size=N, low=0, high=1)
theta = np.random.uniform(size=N, low=0, high=pi/2)

P = sum(x + np.sin(theta) > 1) / N
2/P
#+end_src

#+RESULTS:
: 3.128911138923655


* Using a surface fraction argument

A method that is easier to understand and does not make use of the $\sin$ function is based on the fact that if $X \sim U(0,1)$ and $Y \sim U(0,1)$, then $P[X^2+Y^2 \leq 1] = \pi/4$ (see [[https://en.wikipedia.org/wiki/Monte_Carlo_method]["Monte Carlo method" on Wikipedia]]).
The following code uses this approach:

#+begin_src python :results output file :session :var matplot_lib_filename="figure_pi_mc2.png" :exports both
import matplotlib.pyplot as plt

np.random.seed(seed=42)
x = np.random.uniform(size=N, low=0, high=1)
y = np.random.uniform(size=N, low=0, high=1)

inside = (x**2 + y**2) <= 1
outside = np.logical_not(inside)

fig, ax = plt.subplots(1)
ax.scatter(x[inside], y[inside], c='b', alpha=0.2, edgecolor=None)
ax.scatter(x[outside], y[outside], c='r', alpha=0.2, edgecolor=None)
ax.set_aspect('equal')

plt.savefig(matplot_lib_filename)
print(matplot_lib_filename)
#+end_src

#+RESULTS:
[[file:figure_pi_mc2.png]]

It is then straightforward to obtain a (not really good) approximation to \pi by counting how many times, on average, $X^2 + Y^2$ is smaller than 1:

#+begin_src python :results value :session :exports both
4 * np.mean(inside)
#+end_src

#+RESULTS:
: 3.1556


* Through Wallis' product

[[https://en.wikipedia.org/wiki/Wallis_product][John Wallis' product]] for \pi states that the infinite product below converges to $\pi / 2$.
See the [[https://www.youtube.com/watch?v=8GPy_UMV-08][geometrical proof]].

#+begin_src python :results value :session :exports both
prod = 1
for i in range(2, N):
    prod *= i / (i-1) if i % 2 == 0 else (i-1) / i

prod * 2
#+end_src

#+RESULTS:
: 3.141435562175509


* As the root of a function

As we know, $sin(\pi) = 0$, thus an approximation for \pi can be found by approximating a root of $sin(x)$.
This can be done using [[https://en.wikipedia.org/wiki/Newton%27s_method][Newton's method]], for instace, or any other available numerical analysis tool.

#+begin_src python :results value :session :exports both
from scipy.optimize import fsolve

results = fsolve(sin, x0=3)
results[0]
#+end_src

#+RESULTS:
: 3.141592653589793
