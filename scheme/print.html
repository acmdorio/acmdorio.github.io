<!DOCTYPE HTML>
<html lang="pt-BR" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>((Functional (Scheme)) Maths)</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Oficina de Matemática Funcional em Scheme da SECCOM UFSC 2019">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="navy">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="about.html"><strong aria-hidden="true">1.</strong> Sobre a Oficina</a></li><li><ol class="section"><li><a href="bib.html"><strong aria-hidden="true">1.1.</strong> Bibliografia</a></li></ol></li><li><a href="intro.html"><strong aria-hidden="true">2.</strong> Computando com Scheme</a></li><li><ol class="section"><li><a href="lang.html"><strong aria-hidden="true">2.1.</strong> Sobre Linguagens</a></li><li><a href="eg.html"><strong aria-hidden="true">2.2.</strong> Introdução à Scheme</a></li></ol></li><li><a href="recursion.html"><strong aria-hidden="true">3.</strong> Repetição via Recursão</a></li><li><ol class="section"><li><a href="rec.html"><strong aria-hidden="true">3.1.</strong> Recursão Linear</a></li><li><a href="iter.html"><strong aria-hidden="true">3.2.</strong> Tail-Recursion</a></li><li><a href="lin.html"><strong aria-hidden="true">3.3.</strong> Linearização</a></li></ol></li><li><a href="204.html"><strong aria-hidden="true">4.</strong> Abstração Funcional</a></li><li><ol class="section"><li><a href="204.html"><strong aria-hidden="true">4.1.</strong> Potenciação Rápida</a></li><li><a href="204.html"><strong aria-hidden="true">4.2.</strong> Pontos Fixos</a></li></ol></li><li><a href="204.html"><strong aria-hidden="true">5.</strong> Sistemas Computacionais</a></li><li><ol class="section"><li><a href="204.html"><strong aria-hidden="true">5.1.</strong> Memoization com Closures</a></li><li><a href="204.html"><strong aria-hidden="true">5.2.</strong> Objetos Dinâmicos</a></li><li><a href="204.html"><strong aria-hidden="true">5.3.</strong> Lazy Streams no Infinito</a></li></ol></li><li><a href="204.html"><strong aria-hidden="true">6.</strong> Abstração Metalinguística</a></li><li><ol class="section"><li><a href="204.html"><strong aria-hidden="true">6.1.</strong> Processamento Simbólico</a></li><li><a href="204.html"><strong aria-hidden="true">6.2.</strong> Diferenciação Analítica</a></li></ol></li><li><a href="discussion.html"><strong aria-hidden="true">7.</strong> Finale</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">((Functional (Scheme)) Maths)</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#matemática-funcional-em-scheme" id="matemática-funcional-em-scheme">Matemática Funcional em Scheme</a></h1>
<h2><a class="header" href="#cronograma" id="cronograma">Cronograma</a></h2>
<blockquote>
<ul>
<li>1º Dia: <strong>02 de Outubro, Quarta-feira</strong> <br/>
Horário: <strong>10h10 às 12h00</strong> <br/>
Local: INE sala <strong>INE314</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>2º Dia: <strong>03 de Outubro, Quinta-feira</strong> <br/>
Horário: <strong>10h10 às 12h00</strong> <br/>
Local: CTC sala <strong>LIICT9</strong></li>
</ul>
</blockquote>
<h2><a class="header" href="#como-participar" id="como-participar">Como participar</a></h2>
<p>Confira as datas e horários das <a href="https://seccom-ufsc.github.io/2019/#Oficinas">oficinas da SECCOM</a>. <br/>
Faça a sua <a href="https://docs.google.com/forms/d/e/1FAIpQLScaSQj9MBJJsgE77ef11SWf10cuyUUajxt0GeZkRkNghr4JZQ/viewform"><strong>inscrição</strong></a>.</p>
<h2><a class="header" href="#resumo" id="resumo">Resumo</a></h2>
<p>Scheme é um dos principais &quot;dialetos&quot; de <a href="https://en.wikipedia.org/wiki/Lisp_programming_language">Lisp</a>, que adere ao paradigma funcional e é a <strong>segunda linguagem de programação mais antiga ainda amplamente utilizada</strong>.
Devido à sua flexibilidade e simplicidade, Scheme é usada para extender e customizar o comportamento de outros softwares e foi adotada como <a href="https://www.gnu.org/software/guile/">a linguagem de scripting oficial do GNU Project</a>.</p>
<h2><a class="header" href="#conteúdos-explorados" id="conteúdos-explorados">Conteúdos explorados</a></h2>
<p>O oficina abordará algumas <strong>técnicas de programação funcional</strong> em Scheme para algoritmos matemáticos e métodos numéricos, incluindo:</p>
<ul>
<li><strong>Tipos de recursão e <em>tail call optimization</em></strong></li>
<li><strong>Abstração com funções de alta ordem e <em>closures</em></strong></li>
<li><strong>Paradigma de fluxo de dados (<em>streams</em>): ao infinito e além com <em>lazy evaluation</em></strong></li>
<li><strong>Processamento simbólico e metalinguagem</strong></li>
</ul>
<p>É necessário conhecimento prévio de programação, não necessariamente do paradigma funcional.
Noções de Matemática Discreta e Cálculo Numérico são recomendadas mas não obrigatórias.</p>
<h2><a class="header" href="#ferramentas-utilizadas" id="ferramentas-utilizadas">Ferramentas utilizadas</a></h2>
<p><a href="https://cisco.github.io/ChezScheme/">Chez Scheme</a> (preferência pessoal), <a href="https://www.gnu.org/software/guile/">GNU Guile</a> (disponível na ISO do PET Computação) ou a sua <a href="https://en.wikipedia.org/wiki/Category:Scheme_(programming_language)_implementations">implementação</a> favorita de Scheme.</p>
<h2><a class="header" href="#bibliografia" id="bibliografia">Bibliografia</a></h2>
<p><img src="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/wizard.jpg" alt="The Wizard Book" /></p>
<ul>
<li>
<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html"><strong>Structure and Interpretation of Computer Programs <br/> (SICP, a.k.a. &quot;The Wizard Book&quot;)</strong> <br/> - Abelson H., Sussman G. J.</a></p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/"><strong>MIT OpenCourseWare 6.001 SICP lectures</strong> <br/> - Abelson H., Sussman G. J.</a></p>
</li>
<li>
<p><a href="https://www.scheme.com/tspl4/"><strong>The Scheme Programming Language</strong> <br/> - Dybvig R. K.</a></p>
</li>
<li>
<p><a href="https://ds26gte.github.io/tyscheme/"><strong>Teach Yourself Scheme in Fixnum Days</strong> <br/> - Sitaram D.</a></p>
</li>
<li>
<p><a href="https://htdp.org/2019-02-24/"><strong>How to Design Programs</strong> <br/> - Felleisen M., Findler R. B., Flatt M., Krishnamurthi S.</a></p>
</li>
</ul>
<h2><a class="header" href="#bibliografia-1" id="bibliografia-1">Bibliografia</a></h2>
<p><img src="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/wizard.jpg" alt="The Wizard Book" /></p>
<ul>
<li>
<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html"><strong>Structure and Interpretation of Computer Programs <br/> (SICP, a.k.a. &quot;The Wizard Book&quot;)</strong> <br/> - Abelson H., Sussman G. J.</a></p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/"><strong>MIT OpenCourseWare 6.001 SICP lectures</strong> <br/> - Abelson H., Sussman G. J.</a></p>
</li>
<li>
<p><a href="https://www.scheme.com/tspl4/"><strong>The Scheme Programming Language</strong> <br/> - Dybvig R. K.</a></p>
</li>
<li>
<p><a href="https://ds26gte.github.io/tyscheme/"><strong>Teach Yourself Scheme in Fixnum Days</strong> <br/> - Sitaram D.</a></p>
</li>
<li>
<p><a href="https://htdp.org/2019-02-24/"><strong>How to Design Programs</strong> <br/> - Felleisen M., Findler R. B., Flatt M., Krishnamurthi S.</a></p>
</li>
</ul>
<h1><a class="header" href="#computando-com-scheme" id="computando-com-scheme">Computando com Scheme</a></h1>
<h2><a class="header" href="#sobre-linguagens" id="sobre-linguagens">Sobre Linguagens</a></h2>
<blockquote>
<p>Qualquer notação usada para dar instruções pode ser considerada uma linguagem de programação (<a href="https://www.cs.colorado.edu/%7Ebec/courses/csci5535/reading/densem.pdf">Schmidt</a>).</p>
</blockquote>
<p>Talvez pela familiaridade com a área e a base formal já existente, a maioria das linguagens de programação de uso geral (incluindo Scheme) se baseia em computar funções matemáticas através de expressões.
O mecanismo principal se baseia na &quot;coincidência&quot; de que a <strong>expressão</strong> que descreve o <strong>valor</strong> de uma função pode ser <strong>interpretada</strong> como um <strong>procedimento</strong> para <strong>computar</strong> aquele valor (<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-29.html">Abelson e Sussman, 1968</a>).</p>
<p>Por exemplo, tendo uma função polinomial expressa em &quot;matematiquês&quot;:</p>
<p>\[ x^2 - x - 1 \]</p>
<p>Podemos expressá-la com caracteres padrão em alguma linguagem (por acaso a notação abaixo é código válido de Octave, provavelmente o sendo em mais uma série de outras linguagens):</p>
<pre><code class="language-m">x ^ 2 - x - 1
</code></pre>
<p>Um polinômio equivalente na <a href="https://en.wikipedia.org/wiki/Polish_notation">notação pré-fixada</a> de Lisp seria</p>
<pre><code class="language-scheme">(+ (^ x 2) (- x) -1)
</code></pre>
<h3><a class="header" href="#sintaxe-e-semântica" id="sintaxe-e-semântica">Sintaxe e Semântica</a></h3>
<blockquote>
<p>Programas devem ser escritos para que pessoas possam os ler, e apenas incidentalmente para que máquinas os executem (<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-7.html">Abelson e Sussman, 1968</a>).</p>
</blockquote>
<p>A notação das expressões de uma linguagem específica é dita a sua sintaxe; e mesmo que esse tópico não nos interesse no escopo deste minicurso, começamos falando sobre sintaxe pois apenas expressões sintaticamente corretas possuem semântica, ou seja, significado, associado a elas.</p>
<p>Mais importante ainda, falamos da sintaxe de Scheme para destacar seu minimalismo: ela é composta essencialmente pelas chamadas <strong>expressões simbólicas</strong> (<a href="https://en.wikipedia.org/wiki/S-expression"><em>sexprs</em></a>), cada uma delas caracterizando uma árvore binária, podendo ser:</p>
<ol>
<li>Um átomo; ou</li>
<li>Uma expressão na forma <code>(head . tail)</code> onde <code>head</code> e <code>tail</code> são <em>sexprs</em>.</li>
</ol>
<h3><a class="header" href="#pragmática" id="pragmática">Pragmática</a></h3>
<p>Aos prospectivos utilizadores de uma linguagem de programação interessa mais um outro elemento: a <strong>pragmática</strong>, ou seja, os aspectos práticos da linguagem que a tornam útil para alcançar um conjunto de possíveis objetivos (<a href="https://www2.cs.sfu.ca/%7Ecameron/Teaching/383/syn-sem-prag-meta.html">Cameron</a>).</p>
<p>Neste minicurso será dado enfoque especial à aplicações matemáticas de Scheme como linguagem de programação funcional, onde a principal forma de <strong>abstração</strong> é encontrada na manipulação de funções.</p>
<h3><a class="header" href="#metalinguagem" id="metalinguagem">Metalinguagem</a></h3>
<p>Por último, mas não menos importante, temos a ferramenta com a qual falamos sobre uma linguagem, descrevemos suas características e discutimos suas aplicações: a <strong>metalinguagem</strong> que lhe cabe.</p>
<p>Mais adiante veremos que é possível empregar Scheme como uma linguagem de programação de uso geral que não é especialmente adequada a resolver nenhuma classe de problemas; em vez disso, seu maior potencial está na capacidade de construir e embarcar em si mesma a linguagem mais apta para fazê-lo através de abstrações metalinguísticas (<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-25.html">Abelson e Sussman</a>).</p>
<h2><a class="header" href="#introdução-à-scheme" id="introdução-à-scheme">Introdução à Scheme</a></h2>
<h3><a class="header" href="#programas" id="programas">Programas</a></h3>
<blockquote>
<p>Os atos pelos quais a mente exerce seu poder sobre as idéias são principalmente três:
(1) Combinando várias idéias simples em uma composta e originando assim todas as idéias complexas;
(2) Reunindo duas idéias, simples ou complexas, a fim de ter uma visão delas, sem, contudo, unificá-las numa, obtendo por este meio todas as suas noções das relações;
(3) Separando-as de todas as outras idéias que lhes integram, no processo chamado abstração: deste modo a mente forma todas as suas idéias gerais.
(<a href="https://oll.libertyfund.org/titles/locke-the-works-vol-1-an-essay-concerning-human-understanding-part-1">Locke, 1689</a>)</p>
</blockquote>
<p>Toda a linguagem de programação que se preze possui três mecanismos básicos com os quais expressa programas:</p>
<ol>
<li><strong>Entidades primitivas</strong>: os objetos mais simples dos quais fala a linguagem.</li>
<li><strong>Meios de combinação</strong>: a construção de elementos compostos através de outros mais simples.</li>
<li><strong>Meios de abstração</strong>: pelos quais manipulamos elementos independentemente da sua complexidade.</li>
</ol>
<p>(<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html">Abelson e Sussman</a>).</p>
<h3><a class="header" href="#interpretação" id="interpretação">Interpretação</a></h3>
<p>Para testar os exemplos nas subseções a seguir, utilize alguma implementação de Scheme:</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/">Chez</a> - <strong>Ótimo REPL</strong>, possui um dos interpretadores mais rápidos e uma versão adicional minimalista para distribuição de programas interpretados.</li>
<li><a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">Bigloo</a> - Um exemplo de <strong>transpilador Scheme-&gt;C</strong> que permite gerar binários executáveis e altamente portáveis.</li>
<li><a href="https://www.gnu.org/software/guile/">Guile</a> - É a <strong>linguagem de scripting oficial do GNU Project</strong>, sendo utilizada como linguagem de extensão e configuração do <a href="https://guix.gnu.org/">sistema operacional funcional GuixSD</a>.</li>
<li><a href="https://racket-lang.org/">Racket</a> - Tem uma <strong>IDE feita para Scheme, o Dr. Racket</strong>; oferecendo, além da linguagem padrão, mais um grande conjunto de &quot;dialetos&quot;.</li>
<li><a href="https://ecraven.github.io/r7rs-benchmarks/">Outros</a> - Procure implementações com comunidade ativa e que se adequem aos padrões <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)#Review_of_standard_forms_and_procedures"><em>Revised^n Report on the Algorithmic Language Scheme</em> (RnRS)</a>. Se você deseja alguma <em>feature</em> específica, confira se a sua implementação já a oferece através de algum <a href="https://srfi.schemers.org/"><em>Scheme Request For Implementation</em> (SRFI)</a>.</li>
</ul>
<p>Saiba consultar a <a href="https://docs.racket-lang.org/">documentação</a> da sua implementação. <br/>
Na dúvida, <a href="https://scheme.com/tspl4/">Dybvig</a> e <a href="https://ds26gte.github.io/tyscheme/">Sitaram</a> podem ajudar.</p>
<h3><a class="header" href="#estrutura-a-hrefhttpsdocsracket-langorgracket-cheatindexhtmlexemplosa" id="estrutura-a-hrefhttpsdocsracket-langorgracket-cheatindexhtmlexemplosa">Estrutura (<a href="https://docs.racket-lang.org/racket-cheat/index.html">exemplos</a>)</a></h3>
<h4><a class="header" href="#primitivas" id="primitivas">Primitivas</a></h4>
<p>Alguns exemplos de entidades primitivas em Scheme:</p>
<pre><code class="language-scheme">; numeros
42
0.03
12e-4
67+89i
12/40

; booleanos
#t
#f

; funcoes primitivas
+
-
odd?
even?
car
cdr

; simbolos
'a
'λ
'scheme

; caracteres
#\c
#\f
</code></pre>
<h4><a class="header" href="#combinações" id="combinações">Combinações</a></h4>
<p>Vejamos os meios de combinação presentes em Scheme:</p>
<pre><code class="language-scheme">; pares
(cons 'head 'tail)
(car (cons 1 2))
(cdr (cons 1 2))

; listas
'()
(list 1 2 3)
(cdr '(a b c))

; funcoes anonimas
(lambda (x) x)
(lambda (a b) (+ a b))

; strings
&quot;Hello, Scheme World!&quot;

; vetores
#(1 2 3)
</code></pre>
<h5><a class="header" href="#dados-vs-código" id="dados-vs-código">Dados <em>vs</em> Código</a></h5>
<p>Listas são encadeamentos de pares (como uma corrente) terminadas em <code>'()</code>.
Assim, os dados processados em Scheme possuem exatamente a mesma forma que seu código.
Essa propriedade se chama <a href="https://en.wikipedia.org/wiki/Homoiconicity"><strong>Homoiconicidade</strong></a>.</p>
<h4><a class="header" href="#abstrações" id="abstrações">Abstrações</a></h4>
<p>São alguns meios de abstração de Scheme:</p>
<pre><code class="language-scheme">; nomes temporarios
(let ((x 7)
      (y 8))
  (+ x y))

(let* ((a 2)
       (b (+ a 1))
       (c (* a b)))
  (+ a b c))

; definicoes
(define x 5)

(define (identity x) x)

(define list
  (lambda (first . rest) (cons first rest)))

(define (foo x)
  (define (even? n)
    (display &quot;even? &quot;) (display n) (newline)
    (if (= n 0)
        #t
        (odd? (- n 1))))

  (define (odd? n)
    (display &quot;odd? &quot;) (display n) (newline)
    (if (= n 0)
        #f
        (even? (- n 1))))

  (cond ((even? x) &quot;EVEN&quot;)
        ((odd? x) &quot;ODD&quot;)
        (else &quot;????&quot;)))

; mix
(let 2^ ((n 10)
         (acc 1))
  (if (= n 0) acc
      (2^ (- n 1) (* acc 2))))

(let ((a 1))
  (define (foo x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (display (foo 10)) (newline)
  a)
</code></pre>
<blockquote>
<p>Sim, <code>foo</code> tem vários problemas.
Tente corrigi-los.</p>
<p>Procure escrever em Scheme a definição de um procedimento que calcula em um ponto <code>x</code> o valor do polinômio \( x^2 - x -1 \).</p>
<p>Em seguida, implemente um procedimento <code>(list-ref lst n)</code> que retorna o n-ésimo elemento de uma lista.</p>
</blockquote>
<h2><a class="header" href="#sobre-linguagens-1" id="sobre-linguagens-1">Sobre Linguagens</a></h2>
<blockquote>
<p>Qualquer notação usada para dar instruções pode ser considerada uma linguagem de programação (<a href="https://www.cs.colorado.edu/%7Ebec/courses/csci5535/reading/densem.pdf">Schmidt</a>).</p>
</blockquote>
<p>Talvez pela familiaridade com a área e a base formal já existente, a maioria das linguagens de programação de uso geral (incluindo Scheme) se baseia em computar funções matemáticas através de expressões.
O mecanismo principal se baseia na &quot;coincidência&quot; de que a <strong>expressão</strong> que descreve o <strong>valor</strong> de uma função pode ser <strong>interpretada</strong> como um <strong>procedimento</strong> para <strong>computar</strong> aquele valor (<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-29.html">Abelson e Sussman, 1968</a>).</p>
<p>Por exemplo, tendo uma função polinomial expressa em &quot;matematiquês&quot;:</p>
<p>\[ x^2 - x - 1 \]</p>
<p>Podemos expressá-la com caracteres padrão em alguma linguagem (por acaso a notação abaixo é código válido de Octave, provavelmente o sendo em mais uma série de outras linguagens):</p>
<pre><code class="language-m">x ^ 2 - x - 1
</code></pre>
<p>Um polinômio equivalente na <a href="https://en.wikipedia.org/wiki/Polish_notation">notação pré-fixada</a> de Lisp seria</p>
<pre><code class="language-scheme">(+ (^ x 2) (- x) -1)
</code></pre>
<h3><a class="header" href="#sintaxe-e-semântica-1" id="sintaxe-e-semântica-1">Sintaxe e Semântica</a></h3>
<blockquote>
<p>Programas devem ser escritos para que pessoas possam os ler, e apenas incidentalmente para que máquinas os executem (<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-7.html">Abelson e Sussman, 1968</a>).</p>
</blockquote>
<p>A notação das expressões de uma linguagem específica é dita a sua sintaxe; e mesmo que esse tópico não nos interesse no escopo deste minicurso, começamos falando sobre sintaxe pois apenas expressões sintaticamente corretas possuem semântica, ou seja, significado, associado a elas.</p>
<p>Mais importante ainda, falamos da sintaxe de Scheme para destacar seu minimalismo: ela é composta essencialmente pelas chamadas <strong>expressões simbólicas</strong> (<a href="https://en.wikipedia.org/wiki/S-expression"><em>sexprs</em></a>), cada uma delas caracterizando uma árvore binária, podendo ser:</p>
<ol>
<li>Um átomo; ou</li>
<li>Uma expressão na forma <code>(head . tail)</code> onde <code>head</code> e <code>tail</code> são <em>sexprs</em>.</li>
</ol>
<h3><a class="header" href="#pragmática-1" id="pragmática-1">Pragmática</a></h3>
<p>Aos prospectivos utilizadores de uma linguagem de programação interessa mais um outro elemento: a <strong>pragmática</strong>, ou seja, os aspectos práticos da linguagem que a tornam útil para alcançar um conjunto de possíveis objetivos (<a href="https://www2.cs.sfu.ca/%7Ecameron/Teaching/383/syn-sem-prag-meta.html">Cameron</a>).</p>
<p>Neste minicurso será dado enfoque especial à aplicações matemáticas de Scheme como linguagem de programação funcional, onde a principal forma de <strong>abstração</strong> é encontrada na manipulação de funções.</p>
<h3><a class="header" href="#metalinguagem-1" id="metalinguagem-1">Metalinguagem</a></h3>
<p>Por último, mas não menos importante, temos a ferramenta com a qual falamos sobre uma linguagem, descrevemos suas características e discutimos suas aplicações: a <strong>metalinguagem</strong> que lhe cabe.</p>
<p>Mais adiante veremos que é possível empregar Scheme como uma linguagem de programação de uso geral que não é especialmente adequada a resolver nenhuma classe de problemas; em vez disso, seu maior potencial está na capacidade de construir e embarcar em si mesma a linguagem mais apta para fazê-lo através de abstrações metalinguísticas (<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-25.html">Abelson e Sussman</a>).</p>
<h2><a class="header" href="#introdução-à-scheme-1" id="introdução-à-scheme-1">Introdução à Scheme</a></h2>
<h3><a class="header" href="#programas-1" id="programas-1">Programas</a></h3>
<blockquote>
<p>Os atos pelos quais a mente exerce seu poder sobre as idéias são principalmente três:
(1) Combinando várias idéias simples em uma composta e originando assim todas as idéias complexas;
(2) Reunindo duas idéias, simples ou complexas, a fim de ter uma visão delas, sem, contudo, unificá-las numa, obtendo por este meio todas as suas noções das relações;
(3) Separando-as de todas as outras idéias que lhes integram, no processo chamado abstração: deste modo a mente forma todas as suas idéias gerais.
(<a href="https://oll.libertyfund.org/titles/locke-the-works-vol-1-an-essay-concerning-human-understanding-part-1">Locke, 1689</a>)</p>
</blockquote>
<p>Toda a linguagem de programação que se preze possui três mecanismos básicos com os quais expressa programas:</p>
<ol>
<li><strong>Entidades primitivas</strong>: os objetos mais simples dos quais fala a linguagem.</li>
<li><strong>Meios de combinação</strong>: a construção de elementos compostos através de outros mais simples.</li>
<li><strong>Meios de abstração</strong>: pelos quais manipulamos elementos independentemente da sua complexidade.</li>
</ol>
<p>(<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html">Abelson e Sussman</a>).</p>
<h3><a class="header" href="#interpretação-1" id="interpretação-1">Interpretação</a></h3>
<p>Para testar os exemplos nas subseções a seguir, utilize alguma implementação de Scheme:</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/">Chez</a> - <strong>Ótimo REPL</strong>, possui um dos interpretadores mais rápidos e uma versão adicional minimalista para distribuição de programas interpretados.</li>
<li><a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">Bigloo</a> - Um exemplo de <strong>transpilador Scheme-&gt;C</strong> que permite gerar binários executáveis e altamente portáveis.</li>
<li><a href="https://www.gnu.org/software/guile/">Guile</a> - É a <strong>linguagem de scripting oficial do GNU Project</strong>, sendo utilizada como linguagem de extensão e configuração do <a href="https://guix.gnu.org/">sistema operacional funcional GuixSD</a>.</li>
<li><a href="https://racket-lang.org/">Racket</a> - Tem uma <strong>IDE feita para Scheme, o Dr. Racket</strong>; oferecendo, além da linguagem padrão, mais um grande conjunto de &quot;dialetos&quot;.</li>
<li><a href="https://ecraven.github.io/r7rs-benchmarks/">Outros</a> - Procure implementações com comunidade ativa e que se adequem aos padrões <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)#Review_of_standard_forms_and_procedures"><em>Revised^n Report on the Algorithmic Language Scheme</em> (RnRS)</a>. Se você deseja alguma <em>feature</em> específica, confira se a sua implementação já a oferece através de algum <a href="https://srfi.schemers.org/"><em>Scheme Request For Implementation</em> (SRFI)</a>.</li>
</ul>
<p>Saiba consultar a <a href="https://docs.racket-lang.org/">documentação</a> da sua implementação. <br/>
Na dúvida, <a href="https://scheme.com/tspl4/">Dybvig</a> e <a href="https://ds26gte.github.io/tyscheme/">Sitaram</a> podem ajudar.</p>
<h3><a class="header" href="#estrutura-a-hrefhttpsdocsracket-langorgracket-cheatindexhtmlexemplosa-1" id="estrutura-a-hrefhttpsdocsracket-langorgracket-cheatindexhtmlexemplosa-1">Estrutura (<a href="https://docs.racket-lang.org/racket-cheat/index.html">exemplos</a>)</a></h3>
<h4><a class="header" href="#primitivas-1" id="primitivas-1">Primitivas</a></h4>
<p>Alguns exemplos de entidades primitivas em Scheme:</p>
<pre><code class="language-scheme">; numeros
42
0.03
12e-4
67+89i
12/40

; booleanos
#t
#f

; funcoes primitivas
+
-
odd?
even?
car
cdr

; simbolos
'a
'λ
'scheme

; caracteres
#\c
#\f
</code></pre>
<h4><a class="header" href="#combinações-1" id="combinações-1">Combinações</a></h4>
<p>Vejamos os meios de combinação presentes em Scheme:</p>
<pre><code class="language-scheme">; pares
(cons 'head 'tail)
(car (cons 1 2))
(cdr (cons 1 2))

; listas
'()
(list 1 2 3)
(cdr '(a b c))

; funcoes anonimas
(lambda (x) x)
(lambda (a b) (+ a b))

; strings
&quot;Hello, Scheme World!&quot;

; vetores
#(1 2 3)
</code></pre>
<h5><a class="header" href="#dados-vs-código-1" id="dados-vs-código-1">Dados <em>vs</em> Código</a></h5>
<p>Listas são encadeamentos de pares (como uma corrente) terminadas em <code>'()</code>.
Assim, os dados processados em Scheme possuem exatamente a mesma forma que seu código.
Essa propriedade se chama <a href="https://en.wikipedia.org/wiki/Homoiconicity"><strong>Homoiconicidade</strong></a>.</p>
<h4><a class="header" href="#abstrações-1" id="abstrações-1">Abstrações</a></h4>
<p>São alguns meios de abstração de Scheme:</p>
<pre><code class="language-scheme">; nomes temporarios
(let ((x 7)
      (y 8))
  (+ x y))

(let* ((a 2)
       (b (+ a 1))
       (c (* a b)))
  (+ a b c))

; definicoes
(define x 5)

(define (identity x) x)

(define list
  (lambda (first . rest) (cons first rest)))

(define (foo x)
  (define (even? n)
    (display &quot;even? &quot;) (display n) (newline)
    (if (= n 0)
        #t
        (odd? (- n 1))))

  (define (odd? n)
    (display &quot;odd? &quot;) (display n) (newline)
    (if (= n 0)
        #f
        (even? (- n 1))))

  (cond ((even? x) &quot;EVEN&quot;)
        ((odd? x) &quot;ODD&quot;)
        (else &quot;????&quot;)))

; mix
(let 2^ ((n 10)
         (acc 1))
  (if (= n 0) acc
      (2^ (- n 1) (* acc 2))))

(let ((a 1))
  (define (foo x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (display (foo 10)) (newline)
  a)
</code></pre>
<blockquote>
<p>Sim, <code>foo</code> tem vários problemas.
Tente corrigi-los.</p>
<p>Procure escrever em Scheme a definição de um procedimento que calcula em um ponto <code>x</code> o valor do polinômio \( x^2 - x -1 \).</p>
<p>Em seguida, implemente um procedimento <code>(list-ref lst n)</code> que retorna o n-ésimo elemento de uma lista.</p>
</blockquote>
<h1><a class="header" href="#repetição-via-recursão" id="repetição-via-recursão">Repetição via Recursão</a></h1>
<p>Quando o meio de abstração para procedimentos consiste quase unicamente em definir, nomear e invocar funções, utilizamos recursão para construir processos iterativos (enquanto que em outras linguagens teríamos laços como <code>while</code> e <code>for</code>).</p>
<h2><a class="header" href="#recursão-linear" id="recursão-linear">Recursão Linear</a></h2>
<p>Vejamos o exemplo clássico da função recursiva que calcula o fatorial de um número:</p>
<pre><code class="language-scheme">(define (fac n)
  (if (= n 0) 1
      (* n (fac (- n 1)))))
</code></pre>
<p>Como o procedimento <code>fac</code> é unidirecional e não gera efeitos colaterais - uma <strong>função pura</strong> - podemos computar o processo recursivo através de um modelo simples: basta substituir a definição de <code>fac</code> sempre que encontrarmos uma chamada, trocando também o argumento formal <code>n</code> no esqueleto do procedimento pelo valor passado na evocação.
No exemplo abaixo já foi tomado o branch correto na expressão condicional.</p>
<pre><code class="language-scheme">         (fac 4)
      (* 4 (fac 3))
    (* 4 (* 3 (fac 2)))
  (* 4 (* 3 (* 2 (fac 1))))
(* 4 (* 3 (* 2 (* 1 (fac 0)))))
  (* 4 (* 3 (* 2 (* 1 1))))
    (* 4 (* 3 (* 2 1)))
      (* 4 (* 3 2))
        (* 4 6)
          24
</code></pre>
<p>Destaca-se que a computação deve armazenar no contexto do corpo da função <code>fac</code> a associação do valor da variável <code>n</code>.
Isso acontece pois a multiplicação em <code>(* n (fac (- n 1)))</code> é avaliada somente após o retorno da chamada recursiva.</p>
<p>Assim, o processo transcorre tanto em tempo linear (altura da árvore) como em espaço linear (tamanho da pilha de chamadas) em relação à entrada <code>n</code>.</p>
<h2><a class="header" href="#recursão-iterativa-tail-recursion" id="recursão-iterativa-tail-recursion">Recursão Iterativa: <em>Tail-Recursion</em></a></h2>
<p>Um outro exemplo de procedimento recursivo é o algoritmo de Euclides:</p>
<pre><code class="language-scheme">(define (gcd a b)
  (if (= b 0) a
      (gcd b (modulo a b))))
</code></pre>
<p>Compare o processo gerado com o anterior.</p>
<pre><code class="language-scheme">(gcd 1071 462)
(gcd 462 147)
(gcd 147 21)
(gcd 21 0)
21
</code></pre>
<p>Perceba que no caso do <code>gcd</code>, a computação não exige o armazenamento do contexto antes das chamadas recursivas: <strong>toda a informação necessária encontra-se nos argumentos da função</strong>.</p>
<p>Ambos os procedimentos denotam <strong>recursões lineares</strong>, ou seja, onde a invocação da função ocorre uma única vez durante a sua avaliação.
Entretanto, enquanto <code>fac</code> toma uma quantidade de memória proporcional ao argumento de entrada, o processo descrito por <code>gcd</code> exige espaço constante e portanto constitui ainda uma <strong>iteração linear</strong>.</p>
<p>O que diferencia os dois procedimentos é o fato de que a última expressão no corpo de <code>gcd</code> é a invocação de uma função.
Quando isso acontece dizemos que a função possui uma <a href="https://en.wikipedia.org/wiki/Tail_call"><em>tail-call</em></a> (chamada de cauda ou terminal) e quando a função evocada é recursiva, dizemos que ela é <em><strong>tail-recursive</strong></em>.
Esse fenômeno possibilida a aplicação da chamada <em>Tail Call Optimization</em>, que elimina a necessidade de ocupar espaço na pilha de execução do programa.</p>
<p>A especificação da linguagem Scheme exige que implementações sejam <a href="http://people.csail.mit.edu/jaffer/r5rs/Proper-tail-recursion.html"><em>properly tail-recursive</em></a>, o que significa que o número de execuções de funções em <em>tail-calls</em> sequenciais é <strong>ilimitado</strong>.</p>
<h2><a class="header" href="#recursão-não-linear-e-linearização" id="recursão-não-linear-e-linearização">Recursão Não-Linear e Linearização</a></h2>
<p>Outras classificações de recursão incluem <strong>recursão mútua</strong> (<code>odd?</code> e <code>even?</code> definidas anteriormente) e <strong>recursão múltipla</strong> - onde a função é invocada em seu próprio corpo mais de uma vez.
Um exemplo famoso de recursão múltipla binária é a função que calcula os números da <a href="https://en.wikipedia.org/wiki/Fibonacci_number">sequência de Fibonacci</a>:</p>
<pre><code class="language-scheme">(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</code></pre>
<p>A árvore de chamadas recursivas gerada é bem maior nesse caso:</p>
<pre><code class="language-scheme">                            (fib 4)
          (+ (fib 3)                     (fib 2))
    (+ (fib 2)     (fib 1) )       (+ (fib 1) (fib 0))
(+ (fib 1) (fib 0))    1                 1       0
      1       0
       (+ 1 0)         1              (+ 1       0)
              (+ 1 1)                        1
                            (+ 2 1)
                               3
</code></pre>
<p>Para estimar a complexidade do processo, observe que o número de vezes em que o caso base da recursão é atingido na execução de <code>(fib n)</code> é exatamente igual ao (n+1)ésimo número de Fibonacci.
Isso significa que esse procedimento é calculado em <strong>tempo exponencial</strong> proporcional à \( \phi ^ {n+1} \), onde \(\phi\) é o <a href="https://en.wikipedia.org/wiki/Golden_ratio">número de ouro</a>.</p>
<p>Um primeiro passo para otimizar a computação é expressar o procedimento em uma iteração linear:</p>
<pre><code class="language-scheme">(define (fibo n)
  (let iter ((n n) (prev 1) (curr 0))
    (if (= n 0) curr
        (iter (- n 1) curr (+ prev curr)))))
</code></pre>
<blockquote>
<p>Compare o tempo de execução de <code>fib</code> e <code>fibo</code> para n = 45. <br/>
Aproveite para tentar transformar o procedimento <code>fac</code> em uma iteração linear.</p>
</blockquote>
<p>Alguns processos lineares podem ser otimizados ainda mais se explorarmos alguma propriedade que permita realizar, de uma vez, uma certa operação equivalente a múltiplas iterações.</p>
<pre><code class="language-scheme">;; recursao O(2^(n-1)) para base 2
;; 2^n = 2 * 2^(n-1) = 2^(n-1) + 2^(n-1)
(define (2^ n)
  (cond ((= n 0) 1)
        ((= n 1) 2)
        (else (+ (2^ (- n 1))
                 (2^ (- n 1))))))

;; recursao O(n)
;; b^n = b * b^(n-1)
(define (^ b n)
  (if (= n 0) 1 (* b (^ b (- n 1)))))

;; iteracao O(n)
;; b^n = b * b^(n-1)
(define (^ b n)
  (let iter ((n n) (prod 1))
    (if (= n 0) prod
        (iter (- n 1) (* b prod)))))

;; recursao O(log2(n))
;; b^n = (b^(n/2))^2
(define (^ b n)
  (cond ((= n 0) 1)
        ((even? n) (square (^ b (halve n))))
        (else (* b (^ b (- n 1))))))

;; iteracao O(log2(n))
;; b^n = (b^2)^(n/2)
(define (^ b n)
  (define (iter b n prod)
    (cond ((= n 0) prod)
          ((even? n) (iter (square b) (halve n) prod))
          (else (iter b (- n 1) (* b prod)))))
  (if (&lt; n 0)
      (iter (/ 1 b) (- n) 1)
      (iter b n 1)))

</code></pre>
<pre><code class="language-scheme">;; PS:
(define (halve x) (ash x -1))
(define (square x) (* x x))
</code></pre>
<blockquote>
<p>Tente aplicar a mesma técnica para computar a multiplicação de dois inteiros <code>b</code> e <code>n</code> em tempo logarítmico.
O procedimento resultante deve se assemelhar ao algoritmo de <a href="https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication">multiplicação egípcia/russa</a>.</p>
</blockquote>
<h2><a class="header" href="#recursão-linear-1" id="recursão-linear-1">Recursão Linear</a></h2>
<p>Vejamos o exemplo clássico da função recursiva que calcula o fatorial de um número:</p>
<pre><code class="language-scheme">(define (fac n)
  (if (= n 0) 1
      (* n (fac (- n 1)))))
</code></pre>
<p>Como o procedimento <code>fac</code> é unidirecional e não gera efeitos colaterais - uma <strong>função pura</strong> - podemos computar o processo recursivo através de um modelo simples: basta substituir a definição de <code>fac</code> sempre que encontrarmos uma chamada, trocando também o argumento formal <code>n</code> no esqueleto do procedimento pelo valor passado na evocação.
No exemplo abaixo já foi tomado o branch correto na expressão condicional.</p>
<pre><code class="language-scheme">         (fac 4)
      (* 4 (fac 3))
    (* 4 (* 3 (fac 2)))
  (* 4 (* 3 (* 2 (fac 1))))
(* 4 (* 3 (* 2 (* 1 (fac 0)))))
  (* 4 (* 3 (* 2 (* 1 1))))
    (* 4 (* 3 (* 2 1)))
      (* 4 (* 3 2))
        (* 4 6)
          24
</code></pre>
<p>Destaca-se que a computação deve armazenar no contexto do corpo da função <code>fac</code> a associação do valor da variável <code>n</code>.
Isso acontece pois a multiplicação em <code>(* n (fac (- n 1)))</code> é avaliada somente após o retorno da chamada recursiva.</p>
<p>Assim, o processo transcorre tanto em tempo linear (altura da árvore) como em espaço linear (tamanho da pilha de chamadas) em relação à entrada <code>n</code>.</p>
<h2><a class="header" href="#recursão-iterativa-tail-recursion-1" id="recursão-iterativa-tail-recursion-1">Recursão Iterativa: <em>Tail-Recursion</em></a></h2>
<p>Um outro exemplo de procedimento recursivo é o algoritmo de Euclides:</p>
<pre><code class="language-scheme">(define (gcd a b)
  (if (= b 0) a
      (gcd b (modulo a b))))
</code></pre>
<p>Compare o processo gerado com o anterior.</p>
<pre><code class="language-scheme">(gcd 1071 462)
(gcd 462 147)
(gcd 147 21)
(gcd 21 0)
21
</code></pre>
<p>Perceba que no caso do <code>gcd</code>, a computação não exige o armazenamento do contexto antes das chamadas recursivas: <strong>toda a informação necessária encontra-se nos argumentos da função</strong>.</p>
<p>Ambos os procedimentos denotam <strong>recursões lineares</strong>, ou seja, onde a invocação da função ocorre uma única vez durante a sua avaliação.
Entretanto, enquanto <code>fac</code> toma uma quantidade de memória proporcional ao argumento de entrada, o processo descrito por <code>gcd</code> exige espaço constante e portanto constitui ainda uma <strong>iteração linear</strong>.</p>
<p>O que diferencia os dois procedimentos é o fato de que a última expressão no corpo de <code>gcd</code> é a invocação de uma função.
Quando isso acontece dizemos que a função possui uma <a href="https://en.wikipedia.org/wiki/Tail_call"><em>tail-call</em></a> (chamada de cauda ou terminal) e quando a função evocada é recursiva, dizemos que ela é <em><strong>tail-recursive</strong></em>.
Esse fenômeno possibilida a aplicação da chamada <em>Tail Call Optimization</em>, que elimina a necessidade de ocupar espaço na pilha de execução do programa.</p>
<p>A especificação da linguagem Scheme exige que implementações sejam <a href="http://people.csail.mit.edu/jaffer/r5rs/Proper-tail-recursion.html"><em>properly tail-recursive</em></a>, o que significa que o número de execuções de funções em <em>tail-calls</em> sequenciais é <strong>ilimitado</strong>.</p>
<h2><a class="header" href="#recursão-não-linear-e-linearização-1" id="recursão-não-linear-e-linearização-1">Recursão Não-Linear e Linearização</a></h2>
<p>Outras classificações de recursão incluem <strong>recursão mútua</strong> (<code>odd?</code> e <code>even?</code> definidas anteriormente) e <strong>recursão múltipla</strong> - onde a função é invocada em seu próprio corpo mais de uma vez.
Um exemplo famoso de recursão múltipla binária é a função que calcula os números da <a href="https://en.wikipedia.org/wiki/Fibonacci_number">sequência de Fibonacci</a>:</p>
<pre><code class="language-scheme">(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</code></pre>
<p>A árvore de chamadas recursivas gerada é bem maior nesse caso:</p>
<pre><code class="language-scheme">                            (fib 4)
          (+ (fib 3)                     (fib 2))
    (+ (fib 2)     (fib 1) )       (+ (fib 1) (fib 0))
(+ (fib 1) (fib 0))    1                 1       0
      1       0
       (+ 1 0)         1              (+ 1       0)
              (+ 1 1)                        1
                            (+ 2 1)
                               3
</code></pre>
<p>Para estimar a complexidade do processo, observe que o número de vezes em que o caso base da recursão é atingido na execução de <code>(fib n)</code> é exatamente igual ao (n+1)ésimo número de Fibonacci.
Isso significa que esse procedimento é calculado em <strong>tempo exponencial</strong> proporcional à \( \phi ^ {n+1} \), onde \(\phi\) é o <a href="https://en.wikipedia.org/wiki/Golden_ratio">número de ouro</a>.</p>
<p>Um primeiro passo para otimizar a computação é expressar o procedimento em uma iteração linear:</p>
<pre><code class="language-scheme">(define (fibo n)
  (let iter ((n n) (prev 1) (curr 0))
    (if (= n 0) curr
        (iter (- n 1) curr (+ prev curr)))))
</code></pre>
<blockquote>
<p>Compare o tempo de execução de <code>fib</code> e <code>fibo</code> para n = 45. <br/>
Aproveite para tentar transformar o procedimento <code>fac</code> em uma iteração linear.</p>
</blockquote>
<p>Alguns processos lineares podem ser otimizados ainda mais se explorarmos alguma propriedade que permita realizar, de uma vez, uma certa operação equivalente a múltiplas iterações.</p>
<pre><code class="language-scheme">;; recursao O(2^(n-1)) para base 2
;; 2^n = 2 * 2^(n-1) = 2^(n-1) + 2^(n-1)
(define (2^ n)
  (cond ((= n 0) 1)
        ((= n 1) 2)
        (else (+ (2^ (- n 1))
                 (2^ (- n 1))))))

;; recursao O(n)
;; b^n = b * b^(n-1)
(define (^ b n)
  (if (= n 0) 1 (* b (^ b (- n 1)))))

;; iteracao O(n)
;; b^n = b * b^(n-1)
(define (^ b n)
  (let iter ((n n) (prod 1))
    (if (= n 0) prod
        (iter (- n 1) (* b prod)))))

;; recursao O(log2(n))
;; b^n = (b^(n/2))^2
(define (^ b n)
  (cond ((= n 0) 1)
        ((even? n) (square (^ b (halve n))))
        (else (* b (^ b (- n 1))))))

;; iteracao O(log2(n))
;; b^n = (b^2)^(n/2)
(define (^ b n)
  (define (iter b n prod)
    (cond ((= n 0) prod)
          ((even? n) (iter (square b) (halve n) prod))
          (else (iter b (- n 1) (* b prod)))))
  (if (&lt; n 0)
      (iter (/ 1 b) (- n) 1)
      (iter b n 1)))

</code></pre>
<pre><code class="language-scheme">;; PS:
(define (halve x) (ash x -1))
(define (square x) (* x x))
</code></pre>
<blockquote>
<p>Tente aplicar a mesma técnica para computar a multiplicação de dois inteiros <code>b</code> e <code>n</code> em tempo logarítmico.
O procedimento resultante deve se assemelhar ao algoritmo de <a href="https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication">multiplicação egípcia/russa</a>.</p>
</blockquote>
<h3><a class="header" href="#em-construção" id="em-construção">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-1" id="em-construção-1">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-2" id="em-construção-2">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-3" id="em-construção-3">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-4" id="em-construção-4">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-5" id="em-construção-5">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-6" id="em-construção-6">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-7" id="em-construção-7">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-8" id="em-construção-8">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<h3><a class="header" href="#em-construção-9" id="em-construção-9">Em construção</a></h3>
<p><img src="https://http.cat/204" alt="http.cat" /></p>
<!-- # Esse é o fim
> Ou talvez seja apenas um início.

Os interessados podem continuar seu aprendizado com os tópicos não abordados nessa oficina mas que também são ferramentas muito úteis presentes em Scheme.
Para citar algumas:

- [Interpretadores Metacirculares](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html)
- [Macros Higiênicas](https://en.wikipedia.org/wiki/Hygienic_macro)
- [Computação Não-Determinística](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html)
- [*First-class Continuations*](http://community.schemewiki.org/?call-with-current-continuation)
- [*Threads* e Concorrência](https://www.gnu.org/software/guile/manual/html_node/Threads.html)

## Agradecimentos

![Grand Wizard GJ Sussman](./img/sussman.png)
![Grand Wizard H Abelson](./img/abelson.png) -->
<h2><a class="header" href="#scripts-anexos" id="scripts-anexos">Scripts Anexos</a></h2>
<p>Os trechos de código utilizados na oficina podem ser encontrados no meu <a href="https://github.com/baioc/baioc.github.io/tree/master/seccom-scheme/src/scm">repositório do GitHub</a>.</p>
<h2><a class="header" href="#discussão-e-comentários" id="discussão-e-comentários">Discussão e Comentários</a></h2>
<p>Podem utilizar o espaço abaixo para tirar dúvidas e discutir implementações, assim como apontar quaisquer erros no conteúdo.</p>
<p>Sinta-se também à vontade para deixar sua opinião sobre a oficina, elogiando ou criticando de forma construtiva.</p>
<div id="disqus_thread"></div>
<script>
    /** https://disqus.com/admin/universalcode/#configuration-variables */
    var disqus_config = function () {
        this.page.url = 'https://baioc.github.io/scheme/discussion.html'; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '{{content_id}}'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://baioc.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
